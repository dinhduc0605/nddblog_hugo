[{"categories":null,"content":"Thông thường các hệ thống chỉ có cơ sở dữ liệu (CSDL) của chính nó, nhưng với các hệ thống phức tạp hơn, liên kết với các hệ thống khác thì nhiều khi sẽ phải truy cập trực tiếp vào các CSDL bên ngoài để lấy thông tin. Trên CircleCI, để tạo CSDL của chính hệ thống ta chỉ cần gọi bundle exec rake db:create và bundle exec rake db:migrate (ở đây mình giả sử các bạn sử dụng Rails) là tất cả các bảng sẽ tự động được tạo ra. Nhưng còn CSDL của hệ thống bên ngoài thì làm như thế nào ? Hôm nay mình sẽ giới thiệu với các bạn cách xử lý trong tình huống này. Bước 1: Cài đặt postgres trên CircleCI Cài đặt postgres ta cần chạy các lệnh sau sudo curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | sudo apt-key add - sudo apt-get update \u0026\u0026 sudo apt-get install -y postgresql-client Chú ý trước mỗi câu lệnh đều cần thêm sudo vì để thực hiện các lệnh này trên CircleCI ta cần quyển root Bước 2: Tạo CSDL thứ 2 Khi đã có postgres ta có thể sử dụng câu lệnh SQL để tạo CSDL như sau psql -h localhost -U #{user_name} -c \"CREATE DATABASE #{database_name};\" user_name là giá trị của POSTGRES_USER ta khai báo tại image postgres (giả sử rằng bạn config image postgres trong file config.yml của circleci). Để hiểu hơn về cách viết file config.yml các bạn có thể đọc bài Tích hợp CircleCI trong phát triển ứng dụng Ruby on Rails mình đã viết khá lâu trước đây. Bước 3: Tạo các bảng cần thiết trong CSDL Trong test case các bạn cần đến bảng nào thì tạo thêm bảng đó. Ví dụ mình cần bảng User thì sẽ viết lệnh SQL như sau. Câu lệnh khá là dài vì vậy mình cho vào file users.sql rồi sử dụng tag -f của psql. // users.sql CREATE TABLE public.users ( id serial not null primary key, name string, email string, phone string ) sử dụng psql để tạo bảng users psql -h localhost -U #{user_name} -d #{database_name} -f users.sql Bước 4: Tổng hợp các bước trên Từ các bước trên ta sẽ thêm lệnh run vào config.yml - run: name: Setup Secondary Database command: | sudo curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | sudo apt-key add - sudo apt-get update \u0026\u0026 sudo apt-get install -y postgresql-client psql -h localhost -U #{user_name} -c \"CREATE DATABASE #{database_name};\" psql -h localhost -U #{user_name} -d #{database_name} -f db/sql/users.sql Kết quả Tạo thành công CSDL và các bảng trên CircleCI Như vậy mình đã hướng dẫn các bạn tạo thêm CSDL thứ 2 ngoài CSDL của hệ thống chính trên CircleCI. Chúc các bạn thành công! ","date":"2024-02-24","objectID":"/posts/cach-tao-nhieu-co-so-du-lieu-tren-circleci/:0:0","tags":null,"title":"Cách tạo nhiều cơ sở dữ liệu trên CircleCI","uri":"/posts/cach-tao-nhieu-co-so-du-lieu-tren-circleci/"},{"categories":null,"content":"Tuần trước mình có đi thi Ruby bạc, may mắn là đã đỗ và điểm số cũng không tệ lắm 😎. Vì vậy hôm nay mình viết bài này để chia sẻ với mọi người cách học của mình để thi đỗ trong vòng 3 tuần. Tất nhiên thời gian này cũng chỉ là tương đối, phải dựa trên khả năng của từng người nữa. Nhưng ở đây mình giả sử các bạn đã có kiến thức căn bản về Ruby rồi nhé. 1. Ruby bạc là gì? Từ nãy đến giờ mình cứ chỉ nói là Ruby bạc nên có lẽ nhiều bạn cũng thắc mắc nó là cái gì nhỉ. Ruby bạc tên đầy đủ là Ruby Association Certified Ruby Programmer Silver 2.1, là chứng chỉ do tổ chức Ruby Association cấp chứng nhận kỹ năng và kiến thức về ngôn ngữ Ruby version 2.1. Các bạn cần chú ý số version ở cuối, vì với các version khác nhau ngôn ngữ sẽ có nhiều thay đổi dẫn đến đề thi cũng sẽ thay đổi theo. Ngoài Ruby bạc thì còn có Ruby vàng, Ruby bạch kim là các cấp độ cao hơn. Theo mình biết Ruby bạch kim hiện còn đang trong quá trình phát triển nên hiện tại Ruby vàng là cao nhất. Hiện tại kỳ thi này chỉ được tổ chức tại nhật do công ty Prometric thực hiện. Bạn nào muốn đăng ký có thể vào link sau http://it.prometric-jp.com/testlist/ruby/index.html. Các bạn có thể chọn thi bằng tiếng Anh hoặc tiếng Nhật đều được. Mình thì chọn tiếng Nhật, vì nếu học bằng tiếng Nhật thì vừa có thêm kiến thức chuyên ngành vừa trau dồi được tiếng Nhật. 1 mũi tên trúng 2 con chim. Oh yeah! 🐥🐥 2. Mục đích Vậy thi cái chứng chỉ này liệu có lợi ích gì nhỉ? Có giống như bằng đại học mang về kê chuột không nhỉ? 🤔 Thứ nhất lợi ích thì tất nhiên là phải có rồi, không thì chắc mình cũng không thi đâu, tốn tiền lắm 😭, tận 1.6 man lận (gần 3.5tr VND). Đầu tiên phải kể đến là bạn có thể viết vào CV, khi đi xin việc chắc chắn sẽ được đánh giá cao hơn những người không có rồi. Tiếp đến là thể hiện sự phát triển của bản thân cho người khác biết, đặc biệt là sếp ở công ty rồi. Nếu như ở công ty bạn cảm thấy chưa có gì nổi trội so với các động nghiệp khác, trong khi ngôn ngữ cũng chưa giỏi, thì mình nghĩ cách tốt nhất để thể hiện mình chính là qua các bằng chứng nhận như thế này. Thứ hai nó không giống như bằng đại học để kê chuột đâu nhé, vì nó là e-certificate mà, sẽ được gửi tới qua mail, làm sao mà kê chuột được 😂 3. Tài liệu Vì mình thi bằng tiếng Nhật nên những tài liệu tiếng Anh mình cũng không rõ lắm. Nhưng mình nghĩ là không thiếu đâu, các bạn tìm thử trên Google nhé, mình vừa tìm thì thấy cũng có nhiều lắm. Trong bài viết này mình sẽ chỉ giới thiệu các tài liệu tiếng Nhật mình đã sẽ dụng thôi. ","date":"2024-02-24","objectID":"/posts/cach_do_ruby_bac_trong_3_tuan/:0:0","tags":null,"title":"Cách đỗ Ruby bạc trong 3 tuần","uri":"/posts/cach_do_ruby_bac_trong_3_tuan/"},{"categories":null,"content":"Ruby 技術者認定試験 合格教本 Từ tên sách ta cũng thấy được mục đích của cuốn này là để luyện thi Ruby bạc và vàng, vì vậy mà kiến thức cũng như đề thi thử trong sách rất sát với đề thi thật. Rất tiếc là sách này chỉ có bản tiếng Nhật, chưa có bản tiếng Anh, thế nên đây cũng là 1 trong những lý do mà mình chọn thi bằng tiếng Nhật đấy. Các bạn có thể mua sách tại Amazon ","date":"2024-02-24","objectID":"/posts/cach_do_ruby_bac_trong_3_tuan/:0:1","tags":null,"title":"Cách đỗ Ruby bạc trong 3 tuần","uri":"/posts/cach_do_ruby_bac_trong_3_tuan/"},{"categories":null,"content":"Rex - Ruby examination Đây là trang web luyện đề thi thử Ruby khá là hay. Mặc dù số lượng câu hỏi cũng không nhiều lắm, quanh đi quẩn lại cũng chỉ khoảng 70-80 câu nhưng mình nghĩ nắm rõ những câu hỏi đó cũng đủ để thi rồi. https://rex.libertyfish.co.jp 4. Quá trình học Để có thể đạt hiệu quả cao nhất thì ngay từ đầu mình xác định trước những phần cần phải học. Rõ ràng là hiện tại mình sẽ thi Ruby bạc thì không nhất thiết phải học cả những phần liên quan đến Ruby vàng. Vì vậy mình chỉ tập trung học những cái cần thiết thôi. Đồng thời phân chia thời gian với từng mục tiêu cụ thể như sau: Trong tuần mỗi ngày 1h, Cuối tuần mỗi ngày 4h. Đọc qua sách 1 lượt để hiểu được đại khái nội dung: 1.5 tuần đầu tiên. Vì là lần đầu đọc sách chuyên ngành bằng tiếng Nhật nên còn nhiều từ mới, mình dành khá nhiều thời gian để tra từ, từ nào không biết phải tra ngay lập tức, không được bỏ qua, vì nếu thế lần sau gặp lại từ đó mình vẫn không biết, như vậy thì không trúng con chim thứ 2 là học thêm tiếng Nhật chuyên ngành rồi 😂 Đọc lại sách lần 2 và làm đề thi thử: 1 tuần tiếp theo. Đến thời điểm này thì khả năng đọc cũng tăng nhanh đáng kể, những từ cơ bản hầu như đã quen hết rồi. Đồng thời cũng đã nắm được nội dung cơ bản, lần đọc thứ 2 này để nhớ rõ hơn và giải nghĩa sâu hơn về các định nghĩa cũng như cách vận dụng các lý thuyết có trong sách. Vừa đọc mình vừa note lại những điều cần chú ý hay cảm thấy là dễ quên. Và sau khi xong thì có tập giấy nhỏ nhỏ như thế này. Ôn tập kiến thức và làm đi làm lại các đề thi thử: 0.5 tuần cuối cùng. Đây là lúc mà tập giấy note của mình phát huy tác dụng. Mỗi ngày mình đều đọc lại 1 lần vì đây là những điều mình cho là quan trọng nhất. Đồng thời ngày làm 1 đề thi thử trên trang Rex . Chú ý là sau khi làm các bạn phải kiểm tra kết quả, hiểu rõ được vì sao mình đúng hay vì sao mình sai. Nếu không xem lại thì mình nghĩ dù làm nhiều đề cũng không có nhiều ý nghĩa đâu. Có lẽ sẽ có bạn hỏi tại sao câu đúng cũng phải kiểm tra nhỉ? Vì nhiều lúc dù là câu đúng nhưng mình không chắc chắn 100%, chỉ là chọn theo cảm tính mà lại đúng thôi. Mình cần là sự hiểu rõ và lý giải được tại sao chứ không phải là may mắn. 5. Những điều cần chú ý Khoảng 60-70% câu hỏi là về các phương thức của Array và Hash. Vì vậy cần nắm rõ kiến thức về 2 phần này. Đặc biệt là phân biệt method là 破壊的 (destructive) hay 非破壊的 (nondestructive). Đọc kỹ đề vì sẽ có 1 số câu dễ gây nhầm lẫn. Ví dụ từ 1.9 trở đi Hash có thể viết dưới dạng { a: 1, b: 2 } nhưng chỉ có thể dùng symbol trước dấu :, nếu là string như sau thì không được { ‘a’: 1, ‘b’: 2 }. Nhớ kỹ các method có chức năng giống nhau như map và collect, delete và reject!… Gặp những câu khó thì nên bỏ qua, làm các câu dễ trước, như vậy khi làm hết 1 lượt mình sẽ đoán đại khái được điểm số của mình, nếu cảm thấy ổn thì tinh thần sẽ thoải mái hơn, quay lại làm các câu còn lại sẽ dễ dàng hơn. Cuối cùng, điều đặc biệt quan trọng là tìm sẵn đường đi đến nơi dự thi, nên đến sớm trước khoảng 20 phút đề phòng gặp chuyện không may. Như mình đi rất là sớm, cứ chắc mẩm là đến đợi lâu rồi, thế mà không ngờ vào nhầm cửa ga, đáng lẽ đi tàu điện ngầm lại vào cửa đi tàu điện trên cao. Rồi đến nơi thì tìm mãi không thấy lối vào, loay hoay mãi mới vào được thì vừa kịp giờ. Nên quyết tâm sau này cứ làm gì quan trọng đi sớm 20, 30 phút cho chắc 😖. 6. Kết quả ","date":"2024-02-24","objectID":"/posts/cach_do_ruby_bac_trong_3_tuan/:0:2","tags":null,"title":"Cách đỗ Ruby bạc trong 3 tuần","uri":"/posts/cach_do_ruby_bac_trong_3_tuan/"},{"categories":null,"content":"Hi vọng bài viết của mình sẽ giúp ích cho những bạn sắp tới có dự định thi Ruby bạc nhé ✊ ","date":"2024-02-24","objectID":"/posts/cach_do_ruby_bac_trong_3_tuan/:0:3","tags":null,"title":"Cách đỗ Ruby bạc trong 3 tuần","uri":"/posts/cach_do_ruby_bac_trong_3_tuan/"},{"categories":null,"content":"Dạo này ở công ty mình hay được giao task lấy dữ liệu trực tiếp từ database theo yêu cầu của bên sale. Và để làm được thì tất nhiên là phải viết raw query rồi. Thực sự thì trước mình cũng chỉ mới nắm được các kiến thức cơ bản của SQL thôi chứ cũng chưa có nhiều cơ hội thực hành nên vẫn gà mờ lắm 😭. Mới đầu để viết đc query thoả mãn các yêu cầu thì hầu như mình phải google liên tục, động vào cái gì cũng lơ mơ, rất là khó chịu và mất thời gian. Nhưng dần dần mình cũng quen hơn, nhớ được nhiều câu lệnh hơn, và cảm thấy việc viết SQL khá là thú vị 😌. Mình nhận ra rằng học và nhớ được lý thuyết là 1 chuyện, còn để áp dụng nó vào thực tế lại 1 chuyện khác không hề đơn giản. Vì vậy trong bài viết này mình sẽ không đề cập đến các kiến thức về SQL mà sẽ tập trung vào các trường hợp cụ thể. Lưu ý là các câu lệnh dưới đây đều được viết bằng PostgreSQL nhé, nên có thể sẽ không đúng đối với MySQL, SQLite… Mình sẽ thực hiện truy vấn đối với các bảng như trong hình sau: Các trường hợp ","date":"2024-02-24","objectID":"/posts/cac_cau_lenh_huu_ich_khi_lam_viec_voi_postgresql/:0:0","tags":null,"title":"Các câu lệnh hữu ích khi làm việc với PostgreSQL","uri":"/posts/cac_cau_lenh_huu_ich_khi_lam_viec_voi_postgresql/"},{"categories":null,"content":"1. Tìm các bài viết có chứa 1 trong nhiều từ khoá, ví dụ A B C Thông thường cách đơn giản nhất là sử dụng LIKE nhiều lần với từng giá trị select * from posts where content like '%A%' or content like '%B%' or content like '%C%' Nhưng như vậy ta phải lặp lại content LIKE nhiều lần, rất là bất tiện. Những lúc như vậy ta có thể sử dụng từ khoá SIMILAR TO như sau select * from posts where content similar to '%(A|B|C)%'; ","date":"2024-02-24","objectID":"/posts/cac_cau_lenh_huu_ich_khi_lam_viec_voi_postgresql/:0:1","tags":null,"title":"Các câu lệnh hữu ích khi làm việc với PostgreSQL","uri":"/posts/cac_cau_lenh_huu_ich_khi_lam_viec_voi_postgresql/"},{"categories":null,"content":"2. Trích xuất tên tất cả các user và tên bài viết gần nhất của họ Có 2 cách như sau select u.name, p.title from users u join posts p on p.id = (select max(p2.id) from posts p2 where p2.user_id = u.id group by p2.user_id) select u.name, p.title from users u join posts p on p.user_id = u.id left join posts p2 on p2.user_id = u.id and p.id \u003c p2.id where p2.id isnull ","date":"2024-02-24","objectID":"/posts/cac_cau_lenh_huu_ich_khi_lam_viec_voi_postgresql/:0:2","tags":null,"title":"Các câu lệnh hữu ích khi làm việc với PostgreSQL","uri":"/posts/cac_cau_lenh_huu_ich_khi_lam_viec_voi_postgresql/"},{"categories":null,"content":"3. Kết hợp các cột với nhau thành 1 cột với || Khi bạn muốn trích xuất dữ liệu gộp từ nhiều cột hay sử dụng toán tử ||. select 'Bài viết ' || p.title || ' từ ngày ' || p.created_at::date from posts Với câu lệnh trên ta sẽ lấy được những kết quả dạng như sau Bài viết Các câu lệnh hữu ích khi làm việc với PostgreSQL từ ngày 2019-05-02 ","date":"2024-02-24","objectID":"/posts/cac_cau_lenh_huu_ich_khi_lam_viec_voi_postgresql/:0:3","tags":null,"title":"Các câu lệnh hữu ích khi làm việc với PostgreSQL","uri":"/posts/cac_cau_lenh_huu_ich_khi_lam_viec_voi_postgresql/"},{"categories":null,"content":"4. Trích xuất các bài viết theo thời gian cùng múi giờ Các database thường được lưu dưới múi giờ là 0, trong khi ở Nhật có múi giờ là +9. Vì vậy khi có các điều kiện liên quan đến thời gian ta cần chú ý cộng thêm 9 giờ để được kết quả chính xác. Trong ví dụ này ta sẽ lấy ra các bài viết được viết từ này 01/03/2019 đến ngày 01/04/2019 select id, title from posts where (created_at + interval '9 hours')::date between '2019-03-01' and '2019-04-01' Ta sử dụng interval để cộng thêm 9 giờ vào created_at rồi dùng ::date để ép kiểu từ datetime về date sau đó so sánh như bình thường. ","date":"2024-02-24","objectID":"/posts/cac_cau_lenh_huu_ich_khi_lam_viec_voi_postgresql/:0:4","tags":null,"title":"Các câu lệnh hữu ích khi làm việc với PostgreSQL","uri":"/posts/cac_cau_lenh_huu_ich_khi_lam_viec_voi_postgresql/"},{"categories":null,"content":"5. Kiểm tra 1 hay nhiều giá trị có nằm trong trường định dạng array hay không Giả sửa trong bảng Post có trường like_user_ids dạng array, dùng để lưu id của những người đã like bài viết chẳng hạn. Để tìm những bài viết mà những user có id = 1, 2, 3… đã like ta sử dụng toán tử @\u003e như sau: select id, title from posts where like_user_ids @\u003e Array[1, 2, 3] ","date":"2024-02-24","objectID":"/posts/cac_cau_lenh_huu_ich_khi_lam_viec_voi_postgresql/:0:5","tags":null,"title":"Các câu lệnh hữu ích khi làm việc với PostgreSQL","uri":"/posts/cac_cau_lenh_huu_ich_khi_lam_viec_voi_postgresql/"},{"categories":null,"content":"6. Lấy tổng số lượng trong theo từng khoảng thời gian Trong trường hợp ta muốn lấy số bài được viết theo từng ngày thì nếu như thời gian ở định dạng date ta chỉ việc đơn giản là group_by(date) là xong, nhưng nếu là định dạng timestamp thì ta không thể group_by được vì khi đó thời gian được tính đến bằng giây. Vì vậy ta sẽ dùng to_char để đổi thời gian về dạng tháng rồi group_by theo dữ liệu đó. select to_char(created_at, 'YYYY年MM月') monthly, count(id) count from posts where created_at between '2019-01-01' and '2019-05-31' group by monthly; Tổng kết Trên đây là 1 số ứng dụng trong các trường hợp cụ thể, hi vọng sẽ giúp ích cho các bạn trong những trường hợp tương tự. Mình sẽ cập nhật thêm các ví dụ khác dần dần, các bạn nhớ theo dõi bài viết này thường xuyên nhé 😘 ","date":"2024-02-24","objectID":"/posts/cac_cau_lenh_huu_ich_khi_lam_viec_voi_postgresql/:0:6","tags":null,"title":"Các câu lệnh hữu ích khi làm việc với PostgreSQL","uri":"/posts/cac_cau_lenh_huu_ich_khi_lam_viec_voi_postgresql/"},{"categories":null,"content":"Rails thường được cho là framework rất dễ học và làm quen, bản thân mình cũng cho là như vậy. Nếu chỉ là làm những trang web cơ bản như bán hàng, blog… thì có lẽ chỉ cần học vài tuần, thêm chút kiến thức về bootstrap, jquery là đã đủ dùng. Nhưng, để có thể nắm vững, tối ưu được hệ thống và phục vụ lượng người dùng lớn thì lại là 1 chuyện khác. Để hiểu sâu về Rails ta cũng cần phải đầu tư thời gian nhiều như những ngôn ngữ và framework khác. Chúng ta không thể mong đợi rằng các vấn đề sẽ tự nhiên biến mất chỉ vì chuyển sang dùng 1 công cụ nhanh hơn. 1 thuật toán chạy chậm trong C++ thì hẳn nhiên nó cũng chạy chậm trong Ruby 😔. Trong Rails khi nói đến cải thiện hiệu năng thì có rất nhiều khía cạnh cần quan tâm, trong đó đặc biệt phải nói đến là việc truy vấn đến database. Và vấn đề mà anh em chúng ta thường mắc phải (không biết hoặc biết mà bỏ qua), đó là các N + 1 queries . N + 1 queries là gì? Để hiểu rõ về vấn đề này thì mình sẽ dùng ví dụ sau để các bạn dễ hình dung: class Category \u003c ActiveRecord::Base has_many :posts end class Post \u003c ActiveRecord::Base belongs_to :category end Đây là ví dụ khá điển hình khi làm 1 trang blog, bạn có 2 class là Category và Post có mối quan hệ như trên. Giả sử khi muốn hiển thị tên category của 5 bài đăng gần đây nhất ta thường làm như sau: # Tại controller @lasted_posts = Post.order(:published).limit(5) # Tại View @lasted_posts.each do |post| \u003c%= post.category.name %\u003e end Nhìn qua thì có vẻ như không có vấn đề gì nhưng khi kiểm tra trên cosole ta sẽ thấy các query được sinh ra như sau: Post Load (0.5ms) SELECT \"posts\".* FROM \"posts\" ORDER BY \"posts\".\"published\" ASC LIMIT $1 [[\"LIMIT\", 5]] Category Load (0.3ms) SELECT \"categories\".* FROM \"categories\" WHERE \"categories\".\"id\" = $1 LIMIT $2 [[\"id\", 2], [\"LIMIT\", 1]] Category Load (0.2ms) SELECT \"categories\".* FROM \"categories\" WHERE \"categories\".\"id\" = $1 LIMIT $2 [[\"id\", 3], [\"LIMIT\", 1]] Category Load (0.2ms) SELECT \"categories\".* FROM \"categories\" WHERE \"categories\".\"id\" = $1 LIMIT $2 [[\"id\", 3], [\"LIMIT\", 1]] Category Load (0.2ms) SELECT \"categories\".* FROM \"categories\" WHERE \"categories\".\"id\" = $1 LIMIT $2 [[\"id\", 3], [\"LIMIT\", 1]] Category Load (0.2ms) SELECT \"categories\".* FROM \"categories\" WHERE \"categories\".\"id\" = $1 LIMIT $2 [[\"id\", 3], [\"LIMIT\", 1]] Rails mặc định với cơ chế lazy-load, tức là ứng dụng sẽ chỉ truy vấn tới database khi dữ liệu được yêu cầu như là khi sử dụng các lệnh all, first, count, each. Vì vậy khi ta gọi lệnh each ở đoạn code trên, đầu tiên ứng dụng sẽ query tới 5 bài post gần nhất (1 query). Rồi trong mỗi vòng lặp lại query tới từng category tương ứng của các bài post (5 query). Tổng lại ta có 6 (5 + 1) query, đó là lý do tại sao được gọi là vấn đề n + 1 query. Với ví dụ này, số lượng query vẫn còn ít nên có thể các bạn chưa thấy vấn đề gì cả, và trước đây mình cũng như vậy, vì chỉ toàn làm những project nhỏ và đơn giản thôi mà. Nhưng khi đi làm ở công ty, tiếp xúc với hệ thống dữ liệu lớn tới hàng triệu bản ghi mình mới nhận ra sự khác biệt rất lớn. Khi đó nếu không xử lý tốt thay vì (5 + 1) thì số lượng query có thể lên tới (1.000.000 + 1) (nếu không dùng paging, còn nếu có paging thì thường sẽ là 100 + 1). Lúc đó trang web load rất là lâu, và khi nhìn vào cosole thì thực sự là kinh khủng 😱. Đặc biệt trong trường hợp remote database, mỗi lần truy cập đều tính phí và tốc độ cũng không thể nhanh bằng local database được thì đây là vấn đề thực sự đáng phải quan tâm. Để khắc phục tình trạng này, Rails cung cấp giải pháp rất đơn giản mà hữu ích, đó là eager load. Vậy cụ thể eager load là? 👇 Eager load trong Rails Eager load cho phép ta load dữ liệu từ bảng có quan hệ ngay lập tức, sẽ không cần phải truy vấn từng đối tượng. Cụ thể ở đây sẽ load trực tiếp dữ liệu của Category vào trong các Post ngay khi query tới 5 bài đăng gần nhất. Có 3 phương pháp sử dụng eager load là include, preload và eager_load. Vậy 3 phương pháp này có gì khác nhau, ta sẽ thử lần lượt vào đoạn code ở trên nhé 😉. Ta chỉ cần sửa dòng lệnh đầu tiê","date":"2024-02-24","objectID":"/posts/giai_quyet_van_de_n_plus_1_trong_rails/:0:0","tags":null,"title":"Giải quyết vấn đề N + 1 queries trong Rails","uri":"/posts/giai_quyet_van_de_n_plus_1_trong_rails/"},{"categories":null,"content":"Đầu năm được bạn rủ đi Hakone chơi, có người quen mà cũng có người không quen nên lúc đầu cũng không biết nên đi hay không, cơ mà thôi trước lạ sau quen nên cuối cùng vẫn là cứ đi thôi 😆. Hakone là địa điểm có nhiều suối nước nóng nổi tiếng được nhiều người yêu thích, chưa kể lại còn rất dễ đi từ Tokyo, là nơi vui chơi lý tưởng cho những bạn không có nhiều thời gian. Thường thì có thể đi lại trong ngày nhưng bọn mình đi 2 ngày 1 đêm cho thoải mái. Vì đi gần nên cũng không có gì nhiều phải chuẩn bị, có lẽ 2 việc quan trọng nhất là mua vé tàu và đặt phòng trọ. Nhưng rất may là trong team có đại lý TT béo do 2 đại ca TT và Ken cầm đầu đã giải quyết giúp cả bọn. Thank 2 đại ca nhiều ạ 🙇. Xong 2 việc ý thì còn lại chỉ là chuẩn bị vài bộ quần áo ấm, 1 ít tiền rồi xách balo lên và đi thôi. Đây là lần thứ 2 mình đi chơi “khá” xa tại Nhật, lần trước là leo núi Phú Sỹ. Cả 2 lần đều xuất phát từ Shinjuku nhưng lần này thì gần hơn, đi tàu chưa mất đến 2h là tới nơi rồi ( bình thường đi làm cũng phải gần 1h rồi 😂). Điểm dừng chân đầu tiên là ga Hakone Yumoto. Ở ga này ngoài các suối nước nóng ra thì cũng chẳng có gì hay để xem nên bọn mình đi thẳng về phòng trọ để cất đồ luôn. Phòng trọ gần ga Gora, không xa ga này lắm, tính theo độ cao thì chỉ cách khoảng 500m thôi, thế mà đi tàu rõ là tốn thời gian, chắc phải hơn 30’ ấy 😥. Nhớ lần trước leo núi Phú Sỹ cũng thế, mỗi tầng có mấy trăm mét mà nhiều lúc thấy xa kinh khủng, đi mãi không tới, mệt gần chết, từ đấy cạch leo núi luôn =)))). May lần này là đi tàu nên cũng không cảm thấy mệt mỏi gì . Gửi đồ tại phòng trọ xong mọi người định đi ăn luôn, nhưng có vẻ ga Gora này không có quán nào nhé đủt hơn chục người nên đành leo lên đỉnh núi trước rồi ăn luôn trên ý vậy. Đường lên núi có đường bộ hay không thì mình cũng không biết nhưng thấy ai cũng đi cáp treo nên có lẽ là không có rồi ( thực ra thì có mình cũng không đi 😔 ). À ngoài cáp treo ra thì đoạn đầu còn phải đi bằng cable car ( ケーブルカー ) nữa. Thường thì ở việt nam cable car chính là cáp treo rồi cơ mà bên này nó là loại như hình trên cơ, chắc gọi là tàu điện cáp treo cũng đc nhỉ 😂. Còn cáp treo bên mình hay gọi thì bên này là ロープウェイ. Đi cáp treo lên đỉnh xong mới biết hoá ra gần núi Phú Sỹ đến thế. Công nhận nhìn từ xa đẹp thật, còn leo lên thì…. haizz. Đây mới là lần thứ 2 mình đi cáp treo thôi, nhìn xuống cũng hơi run chân đấy 😣. Mấy đứa còn ¥ ngồi chém gió ra đủ tai nạn, như đang đi mà cáp treo nó mở sàn ra thì thế nào, hay tự nhiên cửa mở ra rồi nó hất mình ra ngoài thì sao… vân vân và mây mây =)))) Vừa lên đến đỉnh núi thì đập vào mắt là quả trứng đen này ( 黒卵 ), ai cũng chụp hình chung với nó, và tất nhiên là mình cũng không ngoại lệ ahihi. Quả trứng này có vẻ nổi tiếng lắm, hỏi mấy anh người nhật ở công ty mà ai cũng biết. Nghe nói là ăn 1 quả tăng 7 năm tuổi thọ, nên chắc cứ 7 năm thì làm 1 chuyến đi Hakone thôi nhỉ 🤔. Đi loanh quanh 1 tí thì thấy cũng chẳng có gì nhiều, toàn mấy cái linh tinh thôi. Xem xong cả bọn bắt đầu đi xuống, à tất nhiên là xuống bằng đường khác rồi, trên đường xuống còn tạt qua đi xem những nơi khác nữa. Có lẽ kỷ niệm đáng nhớ nhất của chuyến đi này là bữa tối ngày hôm ý. Mới 8h tối mà các cửa hàng đã đóng cửa hết, tìm mãi không có quán nào để ăn. Đường thì toàn dốc thẳng đứng lại còn cao nữa, vừa đi vừa nghĩ không biết đi bao lâu mới hết con dốc này, vừa đói vừa mệt mà. Lúc ý mới biết thế nào là trèo đèo đi tìm đồ ăn, may mà còn chưa có lội suối đấy 😢. Đường thì tối om, thỉnh thoảng mới có cái đèn, đi đông còn đỡ chứ 1 mình thì cũng thốn đấy 😏. Leo lên leo xuống mấy con dốc cuối cùng cũng tìm được cái combini Daily Yamazaki, vơ vét được chút đồ ăn xong lúc quay về sao mà thấy người nhẹ nhàng thế không biết =))) Cũng nhờ chuyến đi này mà mình đã học thêm được món bi-a. Từ trước đến giờ còn chưa động vào lần nào, mới chơi thì hơi lóng ngóng cơ mà sau 1 lúc quen dần thấy hay thật, khi nào có cơ hội phải chơi tiếp mới được. Hơi tiếc là nhà trọ chỉ cho chơi đến 10h tối thôi, nên mấy anh em đành đi ngủ sớm, dù sa","date":"2024-02-24","objectID":"/posts/tan_huong_suoi_nuoc_nong_tai_hakono/:0:0","tags":null,"title":"Tận hưởng suối nước nóng tại Hakone","uri":"/posts/tan_huong_suoi_nuoc_nong_tai_hakono/"},{"categories":null,"content":"Trong bài viết trước chúng ta đã Cùng nhau tìm hiểu về Continuous Integration. Vì vậy như đã hứa, hôm nay mình sẽ hướng dẫn các bạn cài đặt và sử dụng 1 trong các công cụ CI phổ biến hiện nay - CircleCI khi phát triển ứng dụng với Ruby on Rails. 1. Đăng ký tài khoản Bước đầu tiên các bạn cần đăng ký tài khoản của CircleCI. Hiện tại công cụ này chỉ hỗ trợ đăng ký bằng tài khoản Github hoặc Bitbucket: Truy cập trang đăng ký https://circleci.com/signup/ Chọn đăng ký bằng Github hoặc Bitbucket. Điền thông tin username, password và xác nhận bảo mật 2 lớp (nếu có) rồi chọn đăng nhập. Sau khi chọn Authorize Application thì Dashboard của CircleCI sẽ hiện ra. Đến đây các bạn đã tạo tài khoản thành công, nhưng để bắt đầu thì còn phải config trong Rails để CircleCI có thể nhận diện và thực thi công việc theo yêu cầu. 2. Config CircleCI trong Rails Trong project tạo thư mục tên là .circleci, và tạo file config.yml ( như vậy filepath sẽ là .circleci/config.yml ). Về nội dung của file config.yml thì tuỳ từng project, từng công việc ta muốn CircleCI thực hiện mà sẽ khác nhau, vì vậy trong bài này mình sẽ lấy file config.yml của nddblog làm ví dụ 😁. # Ruby CircleCI 2.0 configuration file # # Check https://circleci.com/docs/2.0/language-ruby/ for more details # version: 2 jobs: build: docker: # specify the version you desire here - image: circleci/ruby:2.5.3-node-browsers environment: RAILS_ENV: test # Specify service dependencies here if necessary # CircleCI maintains a library of pre-built images # documented at https://circleci.com/docs/2.0/circleci-images/ - image: circleci/postgres:10.6 environment: POSTGRES_USER: dinhduc working_directory: ~/repo steps: - checkout # Download and cache dependencies - restore_cache: keys: - v1-dependencies-{{ checksum \"Gemfile.lock\" }} # fallback to using the latest cache if no exact match is found - v1-dependencies- - run: name: install dependencies command: | bundle install --jobs=4 --retry=3 --path vendor/bundle - save_cache: paths: - ./vendor/bundle key: v1-dependencies-{{ checksum \"Gemfile.lock\" }} # Database setup - run: name: Set up DB command: | bundle exec rake db:create bundle exec rake db:migrate # Run rubocop - run: name: Run rubocop command: bundle exec rubocop # Run tests! - run: name: run tests command: | mkdir /tmp/test-results TEST_FILES=\"$(circleci tests glob 'spec/**/*_spec.rb' | circleci tests split --split-by=timings)\" bundle exec rspec --format progress \\ --format RspecJunitFormatter \\ --out /tmp/test-results/rspec.xml \\ --format progress \\ $TEST_FILES # collect reports - store_test_results: path: /tmp/test-results - store_artifacts: path: /tmp/test-results destination: test-results Mình sẽ giải thích từng phần để các bạn dễ hình dung nhé 😉. version: version của CircleCI, hiện nay đã ra tới 2.1 nhưng trong project của mình vẫn là 2 thôi, chưa có thời gian update mà 😥 jobs: các job cần phải thực hiện mỗi khi build trên CircleCI. build: tên job. docker: là executor, nói đơn giản là nơi để thực hiện các job. Có 3 loại executor khác nhau: docker, machine và macos. image: tên image sẽ được sử dụng trong docker, và những image này được lấy từ dockerhub. Trong nddblog mình sử dụng 2 image là ruby - dùng để chạy project và postgres - dùng để lưu trữ dữ liệu. environment: các biến môi trường của từng image. RAILS_ENV cài đặt môi trường rails trên CircleCI là test. POSTGRES_USER cài đặt username cho database. Lưu ý username ở đây và trong file config/database.yml phải giống nhau. working_directory: thư mục lưu trữ source code. steps: các bước thực hiện trong job. checkout: lấy code của nhánh đang build từ github hoặc bitbucket về. restore_cache: restore các dependencies đã được cache từ lần build trước nếu có. run: thực hiện các command line. Trong file mình có 4 lệnh run lần lượt là cài đặt các dependencies, tạo vào migrate database, chạy test rubocop và chạy rspec test. Nếu các bạn cần chạy lệnh nào khác có thể thêm thoải mái. save_cache: lưu cache lại các dependencies. store_test_results: lư","date":"2024-02-24","objectID":"/posts/tich_hop_circleci_trong_phat_trien_ung_dung_ruby_on_rails/:0:0","tags":null,"title":"Tích hợp CircleCI trong phát triển ứng dụng Ruby on Rails","uri":"/posts/tich_hop_circleci_trong_phat_trien_ung_dung_ruby_on_rails/"},{"categories":null,"content":"Chắc hẳn nhiều bạn cũng đã từng nghe đến cụm từ Continuous Integration ( gọi tắt là CI ), vậy các bạn có từng thắc mắc CI nghĩa là gì, và tại sao lại cần đến nó không? Nếu có hãy cùng mình tìm hiểu thông qua bài viết này nhé 😋. 1. Continuous Integration là? Continuous Integration là cách thức phát triển phần mềm DevOps, trong đó các lập trình viên thường xuyên merge ( hay commit ) code của họ vào các central repo ( như github, gitlab… ), sau đó những đoạn code sẽ được build và test 1 cách tự động. CI thường là nói đến giai đoạn build và tích hợp đoạn code mới vào quá trình release của phần mềm. 2. Tại sao lại cần Continuous Integration? Thông thường, các lập trình viên thường làm việc độc lập trong 1 thời gian dài và chỉ merge code vào nhánh master khi họ đã hoàn thành công việc. Chưa kể đến sau khi merge còn cần phải chờ review, có khi phải đợi đến vài ngày hay cả tuần. Điều này dẫn đến việc merge code gặp khó khăn, tiêu tốn nhiều thời gian, và đồng thời cũng tạo ra nhiều bugs, conflicts… khi mà code không được cập nhật trong thời gian dài. CI giúp tìm ra bug ngay từ sớm trong quá trình phát triển, giúp việc sửa chữa tốn ít công sức hơn, từ đó cải thiện chất lượng phần mềm, giảm thời gian review code, đồng thời rút ngắn thời gian release các chức năng mới của sản phẩm. Việc test tự động được chạy với mỗi lần commit hay pull, đảm bảo nhánh master luôn trong trạng thái ổn định, không bug. 3. Cách thức hoạt động của Continuous Integration Với continuos integration, lập trình viên thường sử dụng git để commit hay merge code của họ vào các central repo như GitHub, GitLab… Trên hình là 1 workflow phổ biến của CI. Thường thì mình sẽ thêm 1 bước là chạy test tại local trước, kiểm tra thật kỹ code của mình, khi xác định không có lỗi thì mới push lên. Làm như vậy sẽ giảm số lần test trên server, vì CI được dùng chung cho cả team, tài nguyên có hạn, nếu quá nhiều build cùng lúc thì sẽ có người phải chờ, và tất nhiên là chẳng ai muốn phải chờ rồi đúng không 😂. Hơn nữa việc đó cũng cho thấy bản thân là người cẩn thận, sẽ được đồng nghiệp đánh giá cao hơn 😜. Sau khi push code lên, thông thường sẽ là gửi pull request vào nhánh master. Lúc này trên server sẽ tự động build và chạy test. Nếu như có lỗi xảy ra thì sẽ được thông báo cho các thành viên trong project, người chịu trách nhiệm cho pull đó ngay lập tức sửa code rồi push lên lần nữa, cứ lặp lại như vậy cho tới khi tất cả các test đều thành công. Tất nhiên đây chỉ là thông qua các test case đã được viết trước, còn về logic của đoạn code thì vẫn cần có người review, nếu ok thì lúc đó mới được merge vào nhánh master. 4. Một số tool Continuos Integration phổ biến Jenkins: Là công cụ mã nguồn mở được viết bằng java do Kohsuke Kawaguchi ( nhân viên của Sun Microsystem thời điểm đó ) viết ra. Jenkins nổi bật trong các công cụ CI ngoài yếu tố miễn phí thì còn nhờ tính linh hoạt, nhiều plugin có thể được tích hợp 1 cách dễ dàng. TeamCity: Là công cụ CI server mạnh mẽ, được phát triển bởi công ty JetBrains, cái tên có lẽ không xa lạ gì với dân dev chúng ta. Công ty này có rất nhiều sản phẩm nổi tiếng như WebStorm, RubyMine, ReSharper…. TeamCity cung cấp đầy đủ tính năng cho phiên bản miễn phí nhưng giới hạn cho 100 lần build cấu hình ( tuỳ chỉnh config của CI ) và 3 build agents ( cho phép chạy song song 3 build cùng lúc ). Công cụ này chạy trên nhiều nền tảng và hỗ trợ nhiều công cụ cũng như framework khác nhau. Đồng thời cũng có lượng lớn plugins được phát triển bới JetBrains cũng như các bên thứ 3. Travis CI: Là 1 trong những giải pháp máy chủ hosted CI lâu đời nhất và được mọi người tin dùng. Mặc dù thường được biết đến là giải pháp máy chủ lưu trữ ( hosted ), nhưng nó cũng cung cấp phiên bản dành cho các doanh nghiệp. Travis CI miễn phí cho tất cả các phần mềm mã nguồn mở được lưu trữ trên GitHub. Nhưng ngược lại nếu không phải thì chỉ được 100 build đầu tiên. Có 1 vài mức giá khác nhau có thể lựa chọn, khác biệt chủ yếu là số lượng build có thể chạy cùng lúc. Circle CI: công cụ được phát t","date":"2024-02-23","objectID":"/posts/cung_nhau_tim_hieu_ve_continuous_integration/:0:0","tags":null,"title":"Cùng nhau tìm hiểu về Continuous Integration","uri":"/posts/cung_nhau_tim_hieu_ve_continuous_integration/"},{"categories":null,"content":"Kể từ bài viết trước cũng đã phải hơn 2 tháng rồi nhỉ, cứ mỗi lần động vào định viết gì đó mà không nghĩ ra gì là mình lại thôi 😂. Hôm nay phải cố gắng lắm mới ngồi được vào máy tính gõ ra vài dòng. Sau 1 hồi đắn đo suy nghĩ thì mình quyết định viết về những kiến thức cũng như kinh nghiệm đã học được từ khi đi làm đến giờ 😎. Trước đây mỗi lần cần tìm kiếm hay sắp xếp dữ liệu mình đều tự viết các câu query, tuy rằng rails cũng có sẵn những method như where, find, order … nhưng nhiều lúc vẫn khá là vất vả, nhất là khi phải query qua nhiều thuộc tính. Gần đây mới biết thêm 1 gem rất thú vị là Ransack - giúp giải quyết vấn đề tìm kiếm và sắp xếp 1 cách nhanh chóng và hiệu quả 😍. Trong bài này mình sẽ giới thiệu sơ qua cách cài đặt cũng như cách sử dụng gem này. Cài đặt Ransack tương thích với Rails 5.0, 5.1 và 5.2 và phiên bản Ruby từ sau 2.2. Nếu bạn sử dụng Rails \u003c 5.0 thì hãy dùng ruby 1.8. Nếu như với ruby 1.8 hay JRuby mà gặp phải vấn đề, hãy sử dụng các phiên bản trước của Ransack (từ 1.3.0 trở xuống). Để cài đặt bạn thêm dòng sau vào Gemfile gem 'ransack' Nếu các bạn muốn sử dụng phiên bản mới nhất thì hãy sử dụng nhánh master gem 'ransack', github: 'activerecord-hackery/ransack' Cách sử dụng Trong controller Method ransack dùng để tìm kiếm dữ trong database dựa vào các điều kiện được truyền từ params[:q], sau đó kết quả được lấy ra thông qua method result. def index @q = Person.ransack(params[:q]) @people = @q.result(distinct: true) end Khi dùng với pagination như kaminari thì không thể dùng distinct: true, nên hãy sử dụng .to_a.uniq: @people = @q.result.includes(:articles).page(params[:page]).to_a.uniq Trong view 2 helper method chính là search_form_for và sort_link, được định nghĩa trong Ransack::Helpers::FormHelper. search_form_for thay thế cho form_for để tạo search form trong view với tham số đầu mặc định là q ( params[:q] ) \u003c%= search_form_for @q do |f| %\u003e # Tìm các phần tử có thuộc tính name chứa... \u003c%= f.label :name_cont %\u003e \u003c%= f.search_field :name_cont %\u003e # Tìm các phần tử nếu trong các articles liên kết tồn tại article có title chứa... \u003c%= f.label :articles_title_start %\u003e \u003c%= f.search_field :articles_title_start %\u003e # Các thuộc tính có thể được nối liền và được tìm kiếm với 1 giá trị duy nhất. \u003c%= f.label :name_or_description_or_email_or_articles_title_cont %\u003e \u003c%= f.search_field :name_or_description_or_email_or_articles_title_cont %\u003e \u003c%= f.submit %\u003e \u003c% end %\u003e Tham số của f.search_field phải được viết dưới dạng như sau: attribute_name[_or_attribute_name]..._predicate. Trong đó attribute_name là tên trường ( thuộc tính ) của model, _or_ là kết hợp thêm dữ liệu của trường ( thuộc tính ) khác, còn _predicate là cont ( chứa ), start ( bắt đầu với )… Như ví dụ ở trên name_or_description_or_email_or_articles_title_cont tức là tìm các Person có name hoặc description hoặc email hoặc ( tồn tại article trong các articles liên kết có title ) chứa chuỗi được nhập vào form. Để truyền format ta làm như sau: \u003c%= search_form_for(@q, format: :pdf) do |f| %\u003e \u003c%= search_form_for(@q, format: :json) do |f| %\u003e sort_link giúp header của các table có thế sắp xếp theo thứ tự tùy theo từng loại dữ liệu ( text, date,… ) \u003c%= sort_link(@q, :name) %\u003e Có thể truyền thêm các tham số khác như tên header, kiểu sắp xếp mặc định: \u003c%= sort_link(@q, :name, 'Last Name', default_order: :desc) %\u003e Sắp xếp với nhiều trường khác nhau: \u003c%= sort_link(@q, :last_name, [:last_name, 'first_name asc'], 'Last Name') %\u003e Như ví dụ trên, đầu tiên sẽ xếp theo last_name rồi đến first_name. Trong trường hợp bạn muốn sắp xếp theo các giá trị phức tạp, như kết quả của 1 lệnh SQL bạn có thể dùng scope. Trong model bạn định nghĩa scope với các thuộc tính ảo mà bạn muốn dùng để sắp xếp: class Person \u003c ActiveRecord::Base scope :sort_by_reverse_name_asc, lambda { order(\"REVERSE(name) ASC\") } scope :sort_by_reverse_name_desc, lambda { order(\"REVERSE(name) DESC\") } ... sau đó sử dụng trong view như sau: \u003c%= sort_link(@q, :reverse_name) %\u003e sort_link khi render trên view sẽ được hiể","date":"2024-02-23","objectID":"/posts/ransack_cong_cu_tim_kiem_hieu_qua/:0:0","tags":null,"title":"Ransack - công cụ tuyệt vời giúp tìm kiếm và sắp xếp dữ liệu đơn giản hơn","uri":"/posts/ransack_cong_cu_tim_kiem_hieu_qua/"},{"categories":null,"content":"Xin chào các bạn, mình là Đức, người tạo ra NDDBlog này. Chắc hẳn nhìn tên là các bạn đã hiểu vì sao blog này lại có tên như vậy rồi nhỉ 😄. Đây là bài viết đầu tiên, vì vậy mình muốn giới thiệu bản thân 1 chút và lý do vì sao blog này ra đời. Mình tốt nghiệp đại học Bách Khoa Hà Nội tháng 7/2017. Sau đó thì mình ở nhà học tiếng Nhật và tìm kiếm công việc bên Nhật. Đến tháng 3 năm nay (2018) mình được nhận vào GA technologies và bắt đầu làm việc bên Nhật từ đó. Về lý do và quá trình mình tìm kiếm công việc tại công ty Nhật thì khi nào có thời gian rảnh mình sẽ viết 1 bài riêng. Công việc thì khi còn học đại học mình hay làm ứng dụng Android, nhưng khi được tuyển vào công ty mình được chỉ định làm về Rails, phát triển hệ thống nội bộ của công ty. Cũng may trước mình đã từng học qua về Rails nên cũng không đến mức khó khăn lắm. Có lẽ giới thiệu về bản thân như vậy là đủ rồi, nếu các bạn có hứng thú có thể xem chỉ tiết hơn ở mục about. Về phần tại sao blog này lại ra đời thì chủ yếu mình muốn có 1 nơi để viết lại những kinh nghiệm của bản thân, không chỉ trong công việc mà trong cả đời sống, đặc biệt là cuộc sống bên Nhật. Như vậy sau này mình đọc lại cũng dễ dàng hơn. Đồng thời nếu như có người đọc và bài viết của mình có thể giúp ích được cho họ thì không còn gì tốt hơn 😇. Từ trước đến giờ khả năng viết lách của mình đều rất kém, nên mong rằng thông qua việc viết blog thường xuyên có thể cải thiện kỹ năng này. Nếu mình viết có gì không đúng, mong các ae ném đá nhiệt tình để mình sửa nhé. Hẹn gặp lại!!! 👋 ","date":"2024-02-23","objectID":"/posts/loi_noi_dau/:0:0","tags":null,"title":"Lời nói đầu","uri":"/posts/loi_noi_dau/"}]