[{"categories":null,"content":"Chắc hẳn nhiều bạn cũng đã từng nghe đến cụm từ Continuous Integration ( gọi tắt là CI ), vậy các bạn có từng thắc mắc CI nghĩa là gì, và tại sao lại cần đến nó không? Nếu có hãy cùng mình tìm hiểu thông qua bài viết này nhé 😋. 1. Continuous Integration là? Continuous Integration là cách thức phát triển phần mềm DevOps, trong đó các lập trình viên thường xuyên merge ( hay commit ) code của họ vào các central repo ( như github, gitlab… ), sau đó những đoạn code sẽ được build và test 1 cách tự động. CI thường là nói đến giai đoạn build và tích hợp đoạn code mới vào quá trình release của phần mềm. 2. Tại sao lại cần Continuous Integration? Thông thường, các lập trình viên thường làm việc độc lập trong 1 thời gian dài và chỉ merge code vào nhánh master khi họ đã hoàn thành công việc. Chưa kể đến sau khi merge còn cần phải chờ review, có khi phải đợi đến vài ngày hay cả tuần. Điều này dẫn đến việc merge code gặp khó khăn, tiêu tốn nhiều thời gian, và đồng thời cũng tạo ra nhiều bugs, conflicts… khi mà code không được cập nhật trong thời gian dài. CI giúp tìm ra bug ngay từ sớm trong quá trình phát triển, giúp việc sửa chữa tốn ít công sức hơn, từ đó cải thiện chất lượng phần mềm, giảm thời gian review code, đồng thời rút ngắn thời gian release các chức năng mới của sản phẩm. Việc test tự động được chạy với mỗi lần commit hay pull, đảm bảo nhánh master luôn trong trạng thái ổn định, không bug. 3. Cách thức hoạt động của Continuous Integration Với continuos integration, lập trình viên thường sử dụng git để commit hay merge code của họ vào các central repo như GitHub, GitLab… Trên hình là 1 workflow phổ biến của CI. Thường thì mình sẽ thêm 1 bước là chạy test tại local trước, kiểm tra thật kỹ code của mình, khi xác định không có lỗi thì mới push lên. Làm như vậy sẽ giảm số lần test trên server, vì CI được dùng chung cho cả team, tài nguyên có hạn, nếu quá nhiều build cùng lúc thì sẽ có người phải chờ, và tất nhiên là chẳng ai muốn phải chờ rồi đúng không 😂. Hơn nữa việc đó cũng cho thấy bản thân là người cẩn thận, sẽ được đồng nghiệp đánh giá cao hơn 😜. Sau khi push code lên, thông thường sẽ là gửi pull request vào nhánh master. Lúc này trên server sẽ tự động build và chạy test. Nếu như có lỗi xảy ra thì sẽ được thông báo cho các thành viên trong project, người chịu trách nhiệm cho pull đó ngay lập tức sửa code rồi push lên lần nữa, cứ lặp lại như vậy cho tới khi tất cả các test đều thành công. Tất nhiên đây chỉ là thông qua các test case đã được viết trước, còn về logic của đoạn code thì vẫn cần có người review, nếu ok thì lúc đó mới được merge vào nhánh master. 4. Một số tool Continuos Integration phổ biến Jenkins: Là công cụ mã nguồn mở được viết bằng java do Kohsuke Kawaguchi ( nhân viên của Sun Microsystem thời điểm đó ) viết ra. Jenkins nổi bật trong các công cụ CI ngoài yếu tố miễn phí thì còn nhờ tính linh hoạt, nhiều plugin có thể được tích hợp 1 cách dễ dàng. TeamCity: Là công cụ CI server mạnh mẽ, được phát triển bởi công ty JetBrains, cái tên có lẽ không xa lạ gì với dân dev chúng ta. Công ty này có rất nhiều sản phẩm nổi tiếng như WebStorm, RubyMine, ReSharper…. TeamCity cung cấp đầy đủ tính năng cho phiên bản miễn phí nhưng giới hạn cho 100 lần build cấu hình ( tuỳ chỉnh config của CI ) và 3 build agents ( cho phép chạy song song 3 build cùng lúc ). Công cụ này chạy trên nhiều nền tảng và hỗ trợ nhiều công cụ cũng như framework khác nhau. Đồng thời cũng có lượng lớn plugins được phát triển bới JetBrains cũng như các bên thứ 3. Travis CI: Là 1 trong những giải pháp máy chủ hosted CI lâu đời nhất và được mọi người tin dùng. Mặc dù thường được biết đến là giải pháp máy chủ lưu trữ ( hosted ), nhưng nó cũng cung cấp phiên bản dành cho các doanh nghiệp. Travis CI miễn phí cho tất cả các phần mềm mã nguồn mở được lưu trữ trên GitHub. Nhưng ngược lại nếu không phải thì chỉ được 100 build đầu tiên. Có 1 vài mức giá khác nhau có thể lựa chọn, khác biệt chủ yếu là số lượng build có thể chạy cùng lúc. Circle CI: công cụ được phát t","date":"2024-02-23","objectID":"/cung_nhau_tim_hieu_ve_continuous_integration/:0:0","tags":null,"title":"Cùng nhau tìm hiểu về Continuous Integration","uri":"/cung_nhau_tim_hieu_ve_continuous_integration/"},{"categories":null,"content":"Kể từ bài viết trước cũng đã phải hơn 2 tháng rồi nhỉ, cứ mỗi lần động vào định viết gì đó mà không nghĩ ra gì là mình lại thôi 😂. Hôm nay phải cố gắng lắm mới ngồi được vào máy tính gõ ra vài dòng. Sau 1 hồi đắn đo suy nghĩ thì mình quyết định viết về những kiến thức cũng như kinh nghiệm đã học được từ khi đi làm đến giờ 😎. Trước đây mỗi lần cần tìm kiếm hay sắp xếp dữ liệu mình đều tự viết các câu query, tuy rằng rails cũng có sẵn những method như where, find, order … nhưng nhiều lúc vẫn khá là vất vả, nhất là khi phải query qua nhiều thuộc tính. Gần đây mới biết thêm 1 gem rất thú vị là Ransack - giúp giải quyết vấn đề tìm kiếm và sắp xếp 1 cách nhanh chóng và hiệu quả 😍. Trong bài này mình sẽ giới thiệu sơ qua cách cài đặt cũng như cách sử dụng gem này. Cài đặt Ransack tương thích với Rails 5.0, 5.1 và 5.2 và phiên bản Ruby từ sau 2.2. Nếu bạn sử dụng Rails \u003c 5.0 thì hãy dùng ruby 1.8. Nếu như với ruby 1.8 hay JRuby mà gặp phải vấn đề, hãy sử dụng các phiên bản trước của Ransack (từ 1.3.0 trở xuống). Để cài đặt bạn thêm dòng sau vào Gemfile gem 'ransack' Nếu các bạn muốn sử dụng phiên bản mới nhất thì hãy sử dụng nhánh master gem 'ransack', github: 'activerecord-hackery/ransack' Cách sử dụng Trong controller Method ransack dùng để tìm kiếm dữ trong database dựa vào các điều kiện được truyền từ params[:q], sau đó kết quả được lấy ra thông qua method result. def index @q = Person.ransack(params[:q]) @people = @q.result(distinct: true) end Khi dùng với pagination như kaminari thì không thể dùng distinct: true, nên hãy sử dụng .to_a.uniq: @people = @q.result.includes(:articles).page(params[:page]).to_a.uniq Trong view 2 helper method chính là search_form_for và sort_link, được định nghĩa trong Ransack::Helpers::FormHelper. search_form_for thay thế cho form_for để tạo search form trong view với tham số đầu mặc định là q ( params[:q] ) \u003c%= search_form_for @q do |f| %\u003e # Tìm các phần tử có thuộc tính name chứa... \u003c%= f.label :name_cont %\u003e \u003c%= f.search_field :name_cont %\u003e # Tìm các phần tử nếu trong các articles liên kết tồn tại article có title chứa... \u003c%= f.label :articles_title_start %\u003e \u003c%= f.search_field :articles_title_start %\u003e # Các thuộc tính có thể được nối liền và được tìm kiếm với 1 giá trị duy nhất. \u003c%= f.label :name_or_description_or_email_or_articles_title_cont %\u003e \u003c%= f.search_field :name_or_description_or_email_or_articles_title_cont %\u003e \u003c%= f.submit %\u003e \u003c% end %\u003e Tham số của f.search_field phải được viết dưới dạng như sau: attribute_name[_or_attribute_name]..._predicate. Trong đó attribute_name là tên trường ( thuộc tính ) của model, _or_ là kết hợp thêm dữ liệu của trường ( thuộc tính ) khác, còn _predicate là cont ( chứa ), start ( bắt đầu với )… Như ví dụ ở trên name_or_description_or_email_or_articles_title_cont tức là tìm các Person có name hoặc description hoặc email hoặc ( tồn tại article trong các articles liên kết có title ) chứa chuỗi được nhập vào form. Để truyền format ta làm như sau: \u003c%= search_form_for(@q, format: :pdf) do |f| %\u003e \u003c%= search_form_for(@q, format: :json) do |f| %\u003e sort_link giúp header của các table có thế sắp xếp theo thứ tự tùy theo từng loại dữ liệu ( text, date,… ) \u003c%= sort_link(@q, :name) %\u003e Có thể truyền thêm các tham số khác như tên header, kiểu sắp xếp mặc định: \u003c%= sort_link(@q, :name, 'Last Name', default_order: :desc) %\u003e Sắp xếp với nhiều trường khác nhau: \u003c%= sort_link(@q, :last_name, [:last_name, 'first_name asc'], 'Last Name') %\u003e Như ví dụ trên, đầu tiên sẽ xếp theo last_name rồi đến first_name. Trong trường hợp bạn muốn sắp xếp theo các giá trị phức tạp, như kết quả của 1 lệnh SQL bạn có thể dùng scope. Trong model bạn định nghĩa scope với các thuộc tính ảo mà bạn muốn dùng để sắp xếp: class Person \u003c ActiveRecord::Base scope :sort_by_reverse_name_asc, lambda { order(\"REVERSE(name) ASC\") } scope :sort_by_reverse_name_desc, lambda { order(\"REVERSE(name) DESC\") } ... sau đó sử dụng trong view như sau: \u003c%= sort_link(@q, :reverse_name) %\u003e sort_link khi render trên view sẽ được hiể","date":"2024-02-23","objectID":"/ransack_cong_cu_tim_kiem_hieu_qua/:0:0","tags":null,"title":"Ransack - công cụ tuyệt vời giúp tìm kiếm và sắp xếp dữ liệu đơn giản hơn","uri":"/ransack_cong_cu_tim_kiem_hieu_qua/"},{"categories":null,"content":"Xin chào các bạn, mình là Đức, người tạo ra NDDBlog này. Chắc hẳn nhìn tên là các bạn đã hiểu vì sao blog này lại có tên như vậy rồi nhỉ 😄. Đây là bài viết đầu tiên, vì vậy mình muốn giới thiệu bản thân 1 chút và lý do vì sao blog này ra đời. Mình tốt nghiệp đại học Bách Khoa Hà Nội tháng 7/2017. Sau đó thì mình ở nhà học tiếng Nhật và tìm kiếm công việc bên Nhật. Đến tháng 3 năm nay (2018) mình được nhận vào GA technologies và bắt đầu làm việc bên Nhật từ đó. Về lý do và quá trình mình tìm kiếm công việc tại công ty Nhật thì khi nào có thời gian rảnh mình sẽ viết 1 bài riêng. Công việc thì khi còn học đại học mình hay làm ứng dụng Android, nhưng khi được tuyển vào công ty mình được chỉ định làm về Rails, phát triển hệ thống nội bộ của công ty. Cũng may trước mình đã từng học qua về Rails nên cũng không đến mức khó khăn lắm. Có lẽ giới thiệu về bản thân như vậy là đủ rồi, nếu các bạn có hứng thú có thể xem chỉ tiết hơn ở mục about. Về phần tại sao blog này lại ra đời thì chủ yếu mình muốn có 1 nơi để viết lại những kinh nghiệm của bản thân, không chỉ trong công việc mà trong cả đời sống, đặc biệt là cuộc sống bên Nhật. Như vậy sau này mình đọc lại cũng dễ dàng hơn. Đồng thời nếu như có người đọc và bài viết của mình có thể giúp ích được cho họ thì không còn gì tốt hơn 😇. Từ trước đến giờ khả năng viết lách của mình đều rất kém, nên mong rằng thông qua việc viết blog thường xuyên có thể cải thiện kỹ năng này. Nếu mình viết có gì không đúng, mong các ae ném đá nhiệt tình để mình sửa nhé. Hẹn gặp lại!!! 👋 ","date":"2024-02-23","objectID":"/loi_noi_dau/:0:0","tags":null,"title":"Lời nói đầu","uri":"/loi_noi_dau/"}]